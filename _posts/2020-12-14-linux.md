---
title: 2020-12-12-linux
tags: linux
categories: [Blogging, Demo]
---
# CSDN Linux操作感想

## linux基本指令

### 文件和目录

cd /home 进入 '/ home' 目录' 
cd .. 返回上一级目录 
cd ../.. 返回上两级目录 
cd 进入个人的主目录 
cd - 返回上次所在的目录 
pwd 显示工作路径 
ls 查看目录中的文件 
ls -F 查看目录中的文件 
ls -l 显示文件和目录的详细资料  
mkdir dir 创建一个叫做 'dir' 的目录' 
mkdir dir1 dir2 同时创建两个目录 
rm -f file 删除一个叫做 'file' 的文件



### APT软件工具

apt-get install package_name 安装/更新一个 deb 包 
apt-get update 升级列表中的软件包 
apt-get upgrade 升级所有已安装的软件 
apt-get remove package_name 从系统删除一个deb包 
apt-get check 确认依赖的软件仓库正确 
apt-get clean 从下载的软件包中清理缓存 

## Linux下的c程序

### 多文件操作

涉及思想:头文件与函数定义分离,makefile编写

[教程](https://www.imooc.com/learn/248)

- 程序简述:编写了一个跳台阶程序，可以跳1级或2级,输入台阶数,输出跳法个数(类似斐波那契数列)
- 文件组成: taojie.c  solution.c solution.h Makefile

```c
//taijie.c 主函数,输入参数
#include<stdio.h>
#include<stdlib.h>
#include"solution.h"

int main(int argc,char * argv[])//int argc ,char *argv[]
{
	int n=0;
	printf("please input the tjs:\n");
	scanf("%d",&n);
	//n=atoi(argv[1]);
	//fprintf(stdout,"please input the tjs:%s\n",argv[1]);
	if(0>=n){
		fprintf(stderr,"n must >0!\n");
		return 1;
	}else{
		printf("you have %d solutions\n",solution(n));
	}
	return 0;
}
```

```c
//solution.c 调用函数定义
int solution(int n){
	if(n<=2) return n;
	else{
		return solution(n-1)+solution(n-2);
	}
}

```

```c
//solution.h 调用函数声明
int solution(int a);
```

```c
//Makefile 整理源文件
taojie.out:solution.o taojie.c
	gcc -g solution.o taojie.c -o taojie.out
solution.o:solution.c
	gcc -c -g solution.c

```

![image-20201210105154896](/home/wuqiushi/.config/Typora/typora-user-images/image-20201210105154896.png)

### 输入输出流错误流

- 输入流

建立input.txt存储输入数据,这里示例存放10

```c
./taojie.out <input.txt
```

![image-20201210105647238](/home/wuqiushi/.config/Typora/typora-user-images/image-20201210105647238.png)

- 输出流

建立output.txt存储输出数据

```c
./taojie.out >output.txt
```

查看output.txt内容:

![image-20201210105845732](/home/wuqiushi/.config/Typora/typora-user-images/image-20201210105845732.png)

- 错误流

输入台阶数为非正数情况:

![image-20201210110118644](/home/wuqiushi/.config/Typora/typora-user-images/image-20201210110118644.png)

## GDB调试

### 常用命令

[来源](https://blog.csdn.net/mercy_ps/article/details/81542986)

- start          #开始调试,停在第一行代码处,(gdb)start
- l              #list的缩写查看源代码,(gdb) l [number/function]
- b <lines>       #b: Breakpoint的简写，**设置断点**。(gdb) b 10
- b <func>       #b: Breakpoint的简写，设置断点。(gdb) b main
- b filename:[line/function] #b:在文件filename的某行或某个函数处设置断点
- i breakpoints #i:info 的简写。(gdb)i breakpoints
- d [bpNO]     #d: Delete breakpoint的简写，删除指定编号的某个断点，或删除所有断点。断点编号从1开始递增。 (gdb)d 1
- s           #s: step执行一行源程序代码，如果此行代码中有函数调用，**则进入该函数**；(gdb) s
- n            #n: next执行一行源程序代码，此行**代码中的函数调用也一并执行**。(gdb) n
- r            #Run的简写，运行被调试的程序。如果此前没有下过断点，则执行完整个程序；如果有断点，则程序暂停在第一个可用断点处。(gdb) r
- c            #Continue的简写，继续执行被调试程序，直至下一个断点或程序结束。



### 程序调试

![image-20201210111142511](/home/wuqiushi/.config/Typora/typora-user-images/image-20201210111142511.png)

![image-20201210111209885](/home/wuqiushi/.config/Typora/typora-user-images/image-20201210111209885.png)

## 内存

### 内存空间

[来源](https://blog.csdn.net/weixin_38233274/article/details/80321719)

BSS段：BSS段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。

数据段：数据段（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。

代码段：代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。

堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）若程序员不释放，则会有内存泄漏，系统会不稳定，Windows系统在该进程退出时由OS释放，Linux则只在整个系统关闭时OS才去释放（参考Linux内存管理）。

栈(stack)：栈又称堆栈， 是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变 量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以 栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。

它是由操作系统分配的，内存的申请与回收都由OS管理。

### 图解

![img](https://img-blog.csdn.net/20160824202909498?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

